#include <ESP8266WiFi.h>
#include <ESP8266WebServer.h>

#include <Adafruit_GFX.h>
#include <Adafruit_NeoMatrix.h>
#include <Adafruit_NeoPixel.h>

const char INDEX_HTML[] PROGMEM = R"rawliteral(
<!DOCTYPE HTML>
<html>
<head>
  <title>File Upload</title>
</head>
<body>
  <form action="/upload" method="post" enctype="multipart/form-data">
    <input type="file" id="file_input" name="data" accept=".bin">
    <input type="submit" value="Upload">
  </form>
</body>
</html>
)rawliteral";


const char SETTINGS_HTML[] PROGMEM = R"rawliteral(
<!DOCTYPE HTML>
<html>
<head>
  <title>Adjust Settings</title>
</head>
<body>
  <h3>Adjust Brightness and Delay</h3>
  <form action="/settings" method="post" id="adjust_form">
    Brightness: <input type="range" id="brightness" name="brightness" min="0" max="255" value="{BRIGHTNESS}" oninput="updateBrightnessValue(this.value)">
    <span id="brightness_value">{BRIGHTNESS}</span><br><br>
    Delay (ms): <input type="range" id="delay" name="delay" min="0" max="1000" value="{DELAY}" oninput="updateDelayValue(this.value)">
    <span id="delay_value">{DELAY}</span><br><br>
    <input type="submit" value="Submit">
  </form>

  <script>
  function updateBrightnessValue(val) {
    document.getElementById('brightness_value').textContent = val;
  }

  function updateDelayValue(val) {
    document.getElementById('delay_value').textContent = val;
  }
  </script>
</body>
</html>
)rawliteral";

const char APP_HTML[] PROGMEM = R"rawliteral(
  <!DOCTYPE html>
<html>
<head>
    <title>LED Matrix Animator</title>
    <style>
        body {
            font-family: Arial, sans-serif;
        }

        #container {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        #grid-container {
            display: grid;
            gap: 2px;
            margin: 20px 0;
            cursor: none;
        }

        .cell {
            width: 40px;
            height: 40px;
            border: 1px solid #ddd;
            cursor: pointer;
        }

        .color-palette {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
        }

        .color-box {
            width: 40px;
            height: 40px;
            border: 1px solid #ddd;
            cursor: pointer;
        }

        .color-dialog {
          position: absolute;
          top: 50%;
          left: 50%;
          transform: translate(-50%, -50%);
          padding: 10px;
          background-color: white;
          box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
          z-index: 999;
        }

        .color-dialog label,
        .color-dialog input,
        .color-dialog button {
          display: block;
          margin: 5px;
        }

        .color-dialog button {
          cursor: pointer;
        }

.circle-cursor {
  width: 10px;
  height: 10px;
  border: 1px solid transparent;
  border-radius: 50%;
  background-color: rgba(0, 0, 0, 0.3); /* Semi-transparent background to improve visibility */
  pointer-events: none;
  position: fixed; /* Position the circle cursor absolutely relative to the viewport */
  z-index: 1; /* Set a high z-index to ensure it's above everything else */
}

        #circle-cursor {
  position: absolute;
  display: none;
  width: 20px;
  height: 20px;
  border-radius: 50%;
  background-color: #ffffff; /* Set the background color to white (initially) */
  pointer-events: none; /* Ensure the cursor doesn't interfere with click events */
}
/*
        .circle-cursor {
          width: 10px;
          height: 10px;
          border: 1px solid black;
          border-radius: 50%;
          background-color: transparent;
          pointer-events: none;
          position: absolute;
          z-index: 1;
        }
        */

        #frame-indicator {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
        }

        #frame-indicator span {
            margin: 0 5px;
        }
    </style>
</head>
<body>
    <h1>LED Matrix Animator</h1>
    <div id="container">
        <div id="grid-container" draggable="false">
            <!-- JavaScript code will generate the grid here -->
        </div>
        <div class="color-palette" id="color-palette">
            <!-- Color palette will be generated by JavaScript -->
        </div>
        <div id="frame-indicator">
            <span>Frame:</span>
            <span id="current-frame">0</span>
            <button id="prev-frame" disabled>Previous</button>
            <button id="next-frame">Next</button>
        </div>
        <div id="misc-functions">
            <button id="copy-frame">Copy Previous Frame</button>
            <button id="insert-frame-button">Insert Frame</button>
            <button id="delete-frame-button">Delete Frame</button>
            <button id="fill-frame-button">Fill Frame</button>
        </div>
        <div>
            <label for="num-rows">Rows:</label>
            <input type="number" id="num-rows" min="1" max="32" value="8">
            <label for="num-cols">Columns:</label>
            <input type="number" id="num-cols" min="1" max="32" value="8">
            <button id="generate-grid">New Grid</button>
        </div>
        <div>
            <span>Save file:</span>
            <button id="save-frames">Save Frames</button>
            <button id="save-binary">Send to Neopixel Matrix</button>
        </div>
        <form id="settings-form">
            <div>
            <label for="brightness">Brightness:</label>
            <input type="number" id="brightness" name="brightness" min="0" max="255" value="128">
            <label for="animationDelay">Animation Delay (ms):</label>
            <input type="number" id="animationDelay" name="delay" min="0" max="10000" value="1000">
             <button type="button" id="update-button">Update</button>
        </div>
    </form>
        <div>
            <span>Load file:</span>
            <input type="file" id="load-file" accept=".json">
        </div>
        <!-- Add the circle cursor element, initially hidden -->
        <div id="circle-cursor" class="circle-cursor" style="display: none;"></div>
    </div>
    <script>
        const gridContainer = document.getElementById('grid-container');
        const colorPalette = document.getElementById('color-palette');
        const frameIndicator = document.getElementById('current-frame');
        const prevFrameBtn = document.getElementById('prev-frame');
        const nextFrameBtn = document.getElementById('next-frame');
        const copyFrameBtn = document.getElementById('copy-frame');
        const generateGridBtn = document.getElementById('generate-grid');
        const numRowsInput = document.getElementById('num-rows');
        const numColsInput = document.getElementById('num-cols');
        colors = [{id: 0, color: [255, 255, 255]}, 
                  {id: 1, color: [0, 0, 0]}, 
                  {id: 2, color: [255, 0, 0]}, 
                  {id: 3, color: [255, 165, 0]}, 
                  {id: 4, color: [255, 255, 0]}, 
                  {id: 5, color: [0, 128, 0]}, 
                  {id: 6, color: [0, 0, 255]}, 
                  {id: 7, color: [75, 0, 130]}, 
                  {id: 8, color: [128, 0, 128]}, 
                ];
        let currentColor = colors[0].color;
        let gridState = [[[0, 0, 0]]]; // 3D array to store the grid state 
        let currentFrame = 0;

        // Get a reference to the load file label
//        const fileLabel = document.getElementById('loadFileLabel');
        // Set the new text
//        fileLabel.textContent = 'Select Your File';

        function showColorDialog(color, index) {
          // Check if there's already an open color dialog
          const existingDialog = document.querySelector('.color-dialog');
          if (existingDialog) {
            closeColorDialog(); // Close the existing dialog before opening a new one
          }
          // Assuming color is an object like { r: 255, g: 0, b: 0 }
          const [ r, g, b ] = color;
//          console.log('showColorDialog: color=', color);
//          console.log('showColorDialog: r=', r);
//          console.log('showColorDialog: g=', g);
//          console.log('showColorDialog: b=', b);

          const dialog = document.createElement('div');
          dialog.classList.add('color-dialog');

          const colorLabel = document.createElement('label');
          colorLabel.textContent = 'Color (RGB):';
          dialog.appendChild(colorLabel);

          const colorInput = document.createElement('input');
          colorInput.type = 'text';
          colorInput.value = r + ', ' + g + ', ' + b;
          // Add event listener to stop propagation of arrow key events
          colorInput.addEventListener('keydown', (event) => {
            if (event.key === 'ArrowUp' || event.key === 'ArrowDown' || event.key === 'ArrowLeft' || event.key === 'ArrowRight') {
              event.stopPropagation();
            }
          });
          dialog.appendChild(colorInput);

          const applyButton = document.createElement('button');
          applyButton.textContent = 'Apply';
          applyButton.addEventListener('click', () => {
            const newColor = colorInput.value
              .split(',')
              .map((c) => parseInt(c.trim(), 10));
            if (isValidColor(newColor)) {
              colors[index] = {id:index, color:newColor};
//  console.log('colors: ', colors);
              updateColorPalette();
              closeColorDialog();
              // Update circle color since apply also selects the new color
              currentColor = colors[index].color; // Set currentColor from the color array
              const [r, g, b] = currentColor; // Destructure the RGB values
              const circleCursor = document.getElementById('circle-cursor');
              circleCursor.style.backgroundColor = `rgb(${r}, ${g}, ${b})`;
            } else {
              alert('Invalid color format. Please enter three comma-separated integers.');
            }
          });
          dialog.appendChild(applyButton);

          const cancelButton = document.createElement('button');
          cancelButton.textContent = 'Cancel';
          cancelButton.addEventListener('click', () => {
            closeColorDialog();
          });
          dialog.appendChild(cancelButton);

          document.body.appendChild(dialog);
        }

        function closeColorDialog() {
          const dialog = document.querySelector('.color-dialog');
          if (dialog) {
            document.body.removeChild(dialog);
          }
        }

        function isValidColor(color) {
          if (color.length !== 3) {
            return false;
          }
          return color.every((c) => Number.isInteger(c) && c >= 0 && c <= 255);
        }

        function updateColorPalette() {
          const colorBoxes = document.querySelectorAll('.color-box');
          colorBoxes.forEach((colorBox, index) => {
            const color = colors[index].color; // Extract the color array from the color object
            const [r, g, b] = color; // Destructure the RGB values
            colorBox.style.backgroundColor = `rgb(${r}, ${g}, ${b})`;
          });
        }

        function createCell(row, col, bgcol) {
            const cell = document.createElement('div');
            cell.classList.add('cell');
            cell.dataset.row = row;
            cell.dataset.col = col;
            cell.style.backgroundColor = `rgb(${bgcol[0]}, ${bgcol[1]}, ${bgcol[2]})`;
            cell.draggable = false;
            cell.addEventListener('click', handleCellClick);
            return cell;
        }


        function createGrid(rows, cols) {
            gridContainer.innerHTML = ''; // Clear existing grid
            gridContainer.style.gridTemplateColumns = `repeat(${cols}, 40px)`; // Update CSS grid columns
            gridContainer.style.gridTemplateRows = `repeat(${rows}, 40px)`; // Update CSS grid rows

            // Create new empty frame
            const frameData = [];
            for (let row = 0; row < rows; row++) {
                const rowArray = [];
                const black = [0, 0, 0];
                for (let col = 0; col < cols; col++) {
                    rowArray.push(black);
                    gridContainer.appendChild(createCell(row, col, black));
                }
                frameData.push(rowArray);
            }
            gridState.push(frameData);
            currentFrame = 0; // Reset current frame to the first frame
            updateFrameIndicator(); // Update the frame indicator
        }


        function handleKeyDown(event) {
            if (event.keyCode === 37) { // Left arrow key
                handlePrevFrame();
            } else if (event.keyCode === 39) { // Right arrow key
                handleNextFrame();
            }
        }

        function handleCellClick(event) {
            const cell = event.target;
            const row = cell.dataset.row;
            const col = cell.dataset.col;

//            console.log('currentcolor:', currentColor);
            cell.style.backgroundColor = `rgb(${currentColor[0]}, ${currentColor[1]}, ${currentColor[2]})`;
            gridState[currentFrame][row][col] = [...currentColor];
        }


        function createColorPalette() {
          colors.forEach((colorObject, index) => {
            const color = colorObject.color; // Extract the color array
            const [r, g, b] = color; // Destructure the RGB values
            const colorBox = document.createElement('div');
            colorBox.classList.add('color-box');
            colorBox.style.backgroundColor = `rgb(${r}, ${g}, ${b})`;

            // Add event listener to handle left-click
            colorBox.addEventListener('click', () => {
              currentColor = colors[index].color; // Set currentColor from the color array
              const [r, g, b] = currentColor; // Destructure the RGB values
              const circleCursor = document.getElementById('circle-cursor');
              circleCursor.style.backgroundColor = `rgb(${r}, ${g}, ${b})`;
            });

            // Add event listener to handle right-click
            colorBox.addEventListener('contextmenu', (event) => {
              event.preventDefault();
              //currentColor = colors[index].color; // Set currentColor from the color array
              //showColorDialog(currentColor, index); 
              showColorDialog(colors[index].color, index); 
            });

            colorPalette.appendChild(colorBox);
          });

          // Also select a default color to begin with          
          // This function is only called to create the palette once. Set selected color to black
          currentColor = colors[0].color; // Works, but does not show in the cirlce....
          const [r, g, b] = currentColor; // Destructure the RGB values
          const circleCursor = document.getElementById('circle-cursor');
          circleCursor.style.backgroundColor = `rgb(${r}, ${g}, ${b})`;
        }


        function updateGrid() {
            gridContainer.innerHTML = ''; // Clear existing grid
            const currentFrameData = gridState[currentFrame];
            const numRows = currentFrameData.length;
            const numCols = currentFrameData[0].length;

            gridContainer.style.gridTemplateColumns = `repeat(${numCols}, 40px)`; // Update CSS grid columns
            gridContainer.style.gridTemplateRows = `repeat(${numRows}, 40px)`; // Update CSS grid rows

            for (let row = 0; row < numRows; row++) {
                for (let col = 0; col < numCols; col++) {
                    const cellData = currentFrameData[row][col];
                    gridContainer.appendChild(createCell(row, col, cellData));
                }
            }
        }



        function updateFrameIndicator() {
            const displayframeindex = currentFrame + 1;
            frameIndicator.textContent = "(" + displayframeindex  + "/" + gridState.length + ")";
            prevFrameBtn.disabled = currentFrame === 0;
        }

        function deepCopyFrame(frameData) {
            const newFrame = [];
            for (let row = 0; row < frameData.length; row++) {
                newFrame.push([]);
                for (let col = 0; col < frameData[row].length; col++) {
                    newFrame[row].push([...frameData[row][col]]);
                }
            }
            return newFrame;
        }


        function addNewFrame() {
            // Create new and empty frame
            const lastFrameData = gridState[gridState.length - 1];
            const emptyFrameData = [];
            const black = [0, 0, 0];
            for (let row = 0; row < lastFrameData.length; row++) {
                const rowArray = [];
                for (let col = 0; col < lastFrameData[row].length; col++) {
                    gridContainer.appendChild(createCell(row, col, black));
                    rowArray.push(black);
                }
                emptyFrameData.push(rowArray);
            }
            gridState.push(emptyFrameData);
            currentFrame = gridState.length - 1; // Increment the frame counter to point to the new frame
        }

        function addNewFrame2() {
          const lastFrameData = gridState[gridState.length - 1];
          const numRows = lastFrameData.length;
          const numCols = lastFrameData[0].length;

          // Create a new frame filled with a default color (e.g., white)
          const newFrame = Array.from({ length: numRows }, () =>
            Array.from({ length: numCols }, () => [0, 0, 0])
          );

          // Add the new frame at the end
          gridState.push(newFrame);

          // Optionally, you may update the display, handle any overflow of frames, etc.
          updateFrameIndicator(); // Update the frame indicator
          updateGrid();
        }



        function insertFrame() {
          const numRows = gridState[currentFrame].length;
          const numCols = gridState[currentFrame][0].length;
        
          // Create a new frame filled with a default color (e.g., white)
          const newFrame = Array.from({ length: numRows }, () =>
            Array.from({ length: numCols }, () => [0, 0, 0])
          );

          // Insert the new frame at the current position
          gridState.splice(currentFrame, 0, newFrame);

          // Optionally, you may update the display, handle any overflow of frames, etc.
          updateFrameIndicator(); // Update the frame indicator
          updateGrid();
        }


        function deleteCurrentFrame() {
          if (gridState.length <= 1) {
            alert("Cannot delete the only frame!");
            return;
          }

          if (currentFrame < gridState.length - 1) {
            // Move all subsequent frames up one position
            for (let i = currentFrame; i < gridState.length - 1; i++) {
              gridState[i] = gridState[i + 1];
            }
          }

          // Remove the last frame
          gridState.pop();

          // Update the current frame if needed
          if (currentFrame === gridState.length) {
            currentFrame--;
          }
          // Refresh the display or whatever else is needed
          updateFrameIndicator(); // Update the frame indicator
          updateGrid();
        }

        function fillCurrentFrame() {
          const numRows = gridState[currentFrame].length;
          const numCols = gridState[currentFrame][0].length;
          for (let row = 0; row < numRows; row++) {
            for (let col = 0; col < numCols; col++) {
              gridState[currentFrame][row][col] = currentColor.slice(); // slice() is used to copy the array
            }
          }
          // Refresh the display or whatever else is needed
          updateGrid();
        }


        function handleNextFrame() {
            currentFrame++;
            if (currentFrame >= gridState.length) {
                //addNewFrame2();
                addNewFrame();
            }
            updateGrid();
            updateFrameIndicator();
        }

        function handlePrevFrame() {
            currentFrame = Math.max(currentFrame - 1, 0);
            updateGrid();
            updateFrameIndicator();
        }

        function copyPreviousFrame() {
            const prevFrameIndex = currentFrame - 1;
            if (prevFrameIndex >= 0) {
                gridState[currentFrame] = deepCopyFrame(gridState[prevFrameIndex]);
                updateGrid();
            }
        }

        function resetGrid() {
            const numRows = parseInt(numRowsInput.value);
            const numCols = parseInt(numColsInput.value);
            gridState = []; // Reset the grid state
            createGrid(numRows, numCols);
        }

        function saveFramesToFile() {
            const gridData = {
                numRows: parseInt(numRowsInput.value),
                numCols: parseInt(numColsInput.value),
                numFrames: gridState.length,
                frames: gridState
            };
            const data = JSON.stringify(gridData);
            const blob = new Blob([data], { type: 'application/json' });
            const url = URL.createObjectURL(blob);

            const a = document.createElement('a');
            a.href = url;
            a.download = 'frames.json';
            a.click();
        
            URL.revokeObjectURL(url);
        }

        function saveBinary() {
            const numRows = parseInt(numRowsInput.value);
            const numCols = parseInt(numColsInput.value);
            const numFrames = gridState.length;

            // Create a new ArrayBuffer with enough space for the header and data
            const buffer = new ArrayBuffer(3 + numFrames * numRows * numCols * 3);
            const dataView = new DataView(buffer);

            // Write the header information
            dataView.setUint8(0, numRows);
            dataView.setUint8(1, numCols);
            dataView.setUint8(2, numFrames);

            // Write the frame data
            let offset = 3;
            for (let frame = 0; frame < numFrames; frame++) {
                for (let row = 0; row < numRows; row++) {
                    for (let col = 0; col < numCols; col++) {
                        const color = gridState[frame][row][col];
                        dataView.setUint8(offset++, color[0]); // r
                        dataView.setUint8(offset++, color[1]); // g
                        dataView.setUint8(offset++, color[2]); // b
                    }
                }
            }

            // Create a Blob and download it
            const blob = new Blob([buffer], { type: 'application/octet-stream' });
            const url = URL.createObjectURL(blob);

            const a = document.createElement('a');
            a.href = url;
            a.download = 'frames.bin';
            a.click();

            URL.revokeObjectURL(url);
        }

        function saveBinary2() {
            const numRows = parseInt(numRowsInput.value);
            const numCols = parseInt(numColsInput.value);
            const numFrames = gridState.length;

            // Create a new ArrayBuffer with enough space for the header and data
            const buffer = new ArrayBuffer(3 + numFrames * numRows * numCols * 3);
            const dataView = new DataView(buffer);

            // Write the header information
            dataView.setUint8(0, numRows);
            dataView.setUint8(1, numCols);
            dataView.setUint8(2, numFrames);

            // Write the frame data
            let offset = 3;
            for (let frame = 0; frame < numFrames; frame++) {
                for (let row = 0; row < numRows; row++) {
                    for (let col = 0; col < numCols; col++) {
                        const color = gridState[frame][row][col];
                        dataView.setUint8(offset++, color[0]); // r
                        dataView.setUint8(offset++, color[1]); // g
                        dataView.setUint8(offset++, color[2]); // b
                    }
                }
            }

            // Create a Blob and download it
            const blob = new Blob([buffer], { type: 'application/octet-stream' });

            // Create a FormData object
            const formData = new FormData();
            formData.append('data', blob, 'frames.bin');

            // Send the POST request to the server
            fetch('/upload', {
                method: 'POST',
                mode: 'no-cors',
                body: formData
            })
            .then(response => response.text())
            .then(text => console.log('Server response:', text))
            .catch(error => console.error('There was an error uploading the file:', error));
        }


        function loadFramesFromFile(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function (e) {
                const contents = e.target.result;
                try {
                    const gridData = JSON.parse(contents);
                    console.log('Loaded gridData:', gridData);

                    const numRows = gridData.numRows;
                    const numCols = gridData.numCols;
                    const numFrames = gridData.numFrames;
                    gridState = gridData.frames; // Update the global gridState variable
                    console.log('Loaded gridState:', gridState);

                    numRowsInput.value = numRows;
                    numColsInput.value = numCols;
                    //createGrid(numRows, numCols); // Update the grid size

                    currentFrame = 0; // Reset to display the first frame in the loaded data
                    updateGrid(); // Update the grid with the correct cell colors
                    updateFrameIndicator();

                } catch (error) {
                    alert('Error parsing file. Please make sure it contains valid frame data.');
                }
            };
            reader.readAsText(file);
        }


        document.getElementById('update-button').addEventListener('click', function() {
          // Create FormData from the form
          const formElement = document.getElementById('settings-form');
          const formData = new FormData(formElement);

          // Post the form data
          fetch('/settings', {
            method: 'POST',
            mode: 'no-cors',
            body: formData
          })
          .then(response => response.text()) // Expecting text response from the server
          .then(text => {
            console.log('Update successful:', text);
          })
          .catch(error => {
            console.error('Error updating settings:', error);
          });
        });


        let isDrawing = false; // Flag to track if the mouse is being held down for drawing

        gridContainer.addEventListener('mousedown', () => {
            isDrawing = true;
        });


        document.addEventListener('mousemove', (event) => {
            if (isDrawing) {
                const cell = event.target;
                if (cell.classList.contains('cell')) {
                    const row = cell.dataset.row;
                    const col = cell.dataset.col;
                    cell.style.backgroundColor = `rgb(${currentColor[0]}, ${currentColor[1]}, ${currentColor[2]})`;
                    gridState[currentFrame][row][col] = [...currentColor];
                }
            }
        });


        document.addEventListener('mouseup', () => {
            isDrawing = false;
        });

        const saveFramesBtn = document.getElementById('save-frames');
        saveFramesBtn.addEventListener('click', saveFramesToFile);

        const saveBinaryBtn = document.getElementById('save-binary');
        saveBinaryBtn.addEventListener('click', saveBinary2);


        const loadFileInput = document.getElementById('load-file');
        loadFileInput.addEventListener('change', loadFramesFromFile);

        document.getElementById('delete-frame-button').addEventListener('click', deleteCurrentFrame);
        document.getElementById('fill-frame-button').addEventListener('click', fillCurrentFrame);
        document.getElementById('insert-frame-button').addEventListener('click', insertFrame);
        nextFrameBtn.addEventListener('click', handleNextFrame);
        prevFrameBtn.addEventListener('click', handlePrevFrame);
        copyFrameBtn.addEventListener('click', copyPreviousFrame);
        generateGridBtn.addEventListener('click', resetGrid);
        document.addEventListener('keydown', handleKeyDown);


        // Add event listeners to show/hide the circle cursor when moving over the grid canvas
        gridContainer.addEventListener('mouseenter', () => {
          const circleCursor = document.getElementById('circle-cursor');
          circleCursor.style.display = 'block';
        });

        gridContainer.addEventListener('mouseleave', () => {
          const circleCursor = document.getElementById('circle-cursor');
          circleCursor.style.display = 'none';
        });

        gridContainer.addEventListener('mousemove', (event) => {
          const circleCursor = document.getElementById('circle-cursor');
          const x = event.clientX;
          const y = event.clientY;
          circleCursor.style.left = `${x}px`;
          circleCursor.style.top = `${y}px`;
          circleCursor.style.display = 'block';
        });

        // Update the event listeners to hide the original cursor only when it's above the grid
        gridContainer.addEventListener('mouseenter', () => {
          document.body.style.cursor = 'none'; // Hide the original cursor when entering the grid
        });

        gridContainer.addEventListener('mouseleave', () => {
          document.body.style.cursor = 'default'; // Restore the original cursor when leaving the grid
        });


        // Set initial grid
        gridState = []; // Reset the grid state
        createGrid(8, 8);
        createColorPalette();
    </script>
</body>
</html>

)rawliteral";



// WiFi credentials
const char* ssid = "Moon";
const char* password = "OIcUrJiHye2";
//const char* ssid = R"rawliteral(NO - FRHANST iPhone H2XJ)rawliteral";
//const char* password = "Aguu28qp";



#define MAX_NUM_ROWS 32
#define MAX_NUM_COLS 32
#define MAX_NUM_FRAMES 40
#define HEADER_SIZE 3
#define MAX_SIZE (MAX_NUM_ROWS * MAX_NUM_COLS * MAX_NUM_FRAMES + HEADER_SIZE)
//#define FRAME_DELAY 500  //ms


uint8_t data[MAX_SIZE];
uint8_t* frames;

volatile uint8_t numRows, numCols, numFrames;
size_t currentWritePosition = 0; // Current write position in frames
bool shouldRunAnimation = false;
int animationDelay = 500; // ms
int brightness = 25;



// Create server at port 80 (http port)
ESP8266WebServer server(80);
//AsyncWebServer server(80);

// The pin for the NeoPixel data line
#define LED_PIN    D4
#define NUM_LEDS   256
Adafruit_NeoPixel strip(NUM_LEDS, LED_PIN, NEO_GRB + NEO_KHZ800);



Adafruit_NeoMatrix* matrix = NULL;


void setup() {
  Serial.begin(9600);
  shouldRunAnimation = false;

  // Connecting to WiFi
  WiFi.begin(ssid, password);
  while (WiFi.status() != WL_CONNECTED) {
    delay(1000);
    Serial.println("Connecting to WiFi...");
  }
  Serial.println("Connected to WiFi");

  // Print the IP address
  Serial.print("IP Address: ");
  Serial.println(WiFi.localIP());


  for(size_t i = 0; i < MAX_SIZE; i++) {
    data[i] = 0;
  }
  Serial.printf("All data memory set to 0\n");


  // Serve the HTML form
  server.on("/manualupload", HTTP_GET, []() {
    server.send_P(200, "text/html", INDEX_HTML); // INDEX_HTML is your HTML form
  });

 // Serve the HTML form
  server.on("/", HTTP_GET, []() {
    server.send_P(200, "text/html", APP_HTML); 
  });

  
  // Define the endpoint for file upload
  server.on("/upload", HTTP_POST, []() {
    server.send(200, "text/plain", "File uploaded");
  }, handleFileUpload);

  // Handle file upload
  server.onFileUpload(handleFileUpload);

   // Define endpoint for parameter settings
  server.on("/settings", handleSettings);

  server.begin();

  // Initialize strip
  strip.begin();
  strip.setBrightness(brightness);
  strip.show(); // Initialize all pixels to 'off'
/*
  for(int i=0; i<NUM_LEDS; i++) {
    strip.setPixelColor(i, strip.Color(0, 0, 100));
    delay(animationDelay);
    strip.show();
  }
*/  

}

void handleSettingsGet() {
  String html = FPSTR(SETTINGS_HTML);
  html.replace("{BRIGHTNESS}", String(brightness)); // Assume brightness is your variable
  html.replace("{DELAY}", String(animationDelay)); // Assume delay is your variable
  server.send(200, "text/html", html);
}

//void handleSettingsGet() {
//  server.send_P(200, "text/html", SETTINGS_HTML);
//}

void handleSettingsPost() {
  if (server.hasArg("delay") && server.hasArg("brightness")) {
    int delayValue = server.arg("delay").toInt();
    int brightnessValue = server.arg("brightness").toInt();
    animationDelay = delayValue;
    brightness = brightnessValue;
    strip.setBrightness(brightnessValue);
    handleSettingsGet();
    //server.send(200, "text/plain", "Settings adjusted");
  } else {
    server.send(400, "text/plain", "Missing delay or brightness argument");
  }
}

void handleSettings() {
  if (server.method() == HTTP_POST) {
    handleSettingsPost();
  } else {
    handleSettingsGet();
  }
}



void handleFileUpload() {
  if (server.uri() != "/upload") return;
  HTTPUpload& upload = server.upload();
  if (upload.status == UPLOAD_FILE_START) {
    Serial.printf("UploadStart: %s\n", upload.filename.c_str());
    shouldRunAnimation = false;
    // Initialize the write position at the start of the upload
    currentWritePosition = 0;
  } else if (upload.status == UPLOAD_FILE_WRITE) {
    Serial.println("Processing upload...");
    // upload.buf contains the received bytes
    // upload.currentSize contains the size of the received chunk

    // Check if we have enough space in frames to copy the incoming data
    if (currentWritePosition + upload.currentSize > MAX_SIZE) {
      Serial.println("Error: Not enough space in frames to copy incoming data!");
      numFrames = 0;
      return;
    }

    Serial.printf("CurrentWritePosition = %d\n", currentWritePosition);
    memcpy(data + currentWritePosition, upload.buf, upload.currentSize);
    currentWritePosition += upload.currentSize;

  } else if (upload.status == UPLOAD_FILE_END) {
    Serial.printf("UploadEnd: %s, %u B\n", upload.filename.c_str(), upload.totalSize);
    numRows = data[0];
    numCols = data[1];
    numFrames = data[2];
    frames = &data[3];
/*
    Serial.printf("r,c,f = %d, %d, %d\n", numRows, numCols, numFrames);
    for (int f=0; f<numFrames; f++){
      for (int i=0; i<numRows; i++){
        for (int j=0; j<numCols; j++){
          uint8_t* v = getValue(f, i, j);
          for (int k=0; k<3; k++){
            //Serial.printf("%4d", frames[f*numRows*numCols*3 + i*numCols*3+j*3+k]);
            Serial.printf("%4d", v[k]);
          }
          Serial.printf("|");
        }
        Serial.printf("\n");
      }
      Serial.printf("-------------------\n");
    }
    */
    shouldRunAnimation = true;
  }
}



// Function to get value from the flat array
uint8_t* getValue(int frame, int row, int col) {
  return &frames[frame * numRows * numCols * 3 + row * numCols * 3 + col * 3];
}

void displayFrame(int frameNum) {
  uint8_t* rgbValues;
  for(int row = 0; row < numRows; row++) {
    for(int col = 0; col < numCols; col++) {
      rgbValues = getValue(frameNum, row, col);
      // Do something with the value, like setting a pixel color
      int pixelNumber = xy2n(row, col);
      strip.setPixelColor(pixelNumber, strip.Color(rgbValues[0], rgbValues[1], rgbValues[2]));
      //strip.setPixelColor(row*numCols + col, strip.Color(rgbValues[0], rgbValues[1], rgbValues[2]));
    }
  }
  strip.show();
}

int xy2n(int x, int y) {
  if(y%2 == 0)
    return(y*numRows + x);
  else
    return((y+1)*numRows - x -1);
}

void loop() {
  server.handleClient();
  // if animation should run, run it
  if (shouldRunAnimation) {
    for (int i = 0; i < numFrames; i++) {
      Serial.printf("Showing frame %d\n", i);
      displayFrame(i);
      delay(animationDelay);
      server.handleClient();
    }
  }
}
